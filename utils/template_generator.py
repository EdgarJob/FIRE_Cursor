import os
import json
import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any, Optional
import requests
from dotenv import load_dotenv
import streamlit as st
import inspect

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Get API key from environment variables
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")

def fix_generated_code(code: str) -> str:
    """
    Fix common issues in code generated by the AI.
    
    Args:
        code: Raw generated code
        
    Returns:
        Fixed code
    """
    # Split code into lines for easier processing
    lines = code.split('\n')
    fixed_lines = []
    
    # Track if we are in a loop to know when 'col' is valid
    in_loop = False
    loop_indentation = 0
    col_variables = set()
    
    for i, line in enumerate(lines):
        # Check for loop start
        if 'for ' in line and ' in ' in line and (':' in line or line.strip().endswith(':')):
            # Extract the loop variable
            loop_var = line.split('for ')[1].split(' in')[0].strip()
            if loop_var == 'col':
                in_loop = True
                # Get the indentation level to know when we exit the loop
                loop_indentation = len(line) - len(line.lstrip())
            elif 'col' in loop_var:
                # Handle cases like "for col_name in..."
                col_variables.add(loop_var)
        
        # Check if we're exiting a loop
        if in_loop and line.strip() and not line.isspace():
            current_indent = len(line) - len(line.lstrip())
            if current_indent <= loop_indentation:
                in_loop = False
        
        # Replace problematic 'col' references outside of loops
        if not in_loop and 'col' in line and not any(var in line for var in col_variables):
            # Don't replace 'col' if it's part of another word like 'color' or 'column'
            for word in ['color', 'column', 'collect', 'coloc', 'colspan']:
                if word in line:
                    continue
            
            # Replace standalone 'col' with column-specific variables
            if ' col ' in line or 'col=' in line or '(col' in line or '[col' in line or ',col' in line or 'col)' in line or 'col]' in line or 'col,' in line:
                # Try to determine the column context
                if 'age' in line.lower():
                    fixed_line = line.replace(' col ', ' age_col ').replace('col=', 'age_col=').replace('(col', '(age_col').replace('[col', '[age_col').replace(',col', ',age_col').replace('col)', 'age_col)').replace('col]', 'age_col]').replace('col,', 'age_col,')
                elif 'gender' in line.lower() or 'sex' in line.lower():
                    fixed_line = line.replace(' col ', ' gender_col ').replace('col=', 'gender_col=').replace('(col', '(gender_col').replace('[col', '[gender_col').replace(',col', ',gender_col').replace('col)', 'gender_col)').replace('col]', 'gender_col]').replace('col,', 'gender_col,')
                else:
                    fixed_line = line.replace(' col ', ' column_name ').replace('col=', 'column_name=').replace('(col', '(column_name').replace('[col', '[column_name').replace(',col', ',column_name').replace('col)', 'column_name)').replace('col]', 'column_name]').replace('col,', 'column_name,')
                
                # Log the change
                logger.info(f"Fixed 'col' reference in line {i+1}: '{line}' -> '{fixed_line}'")
                fixed_lines.append(fixed_line)
            else:
                fixed_lines.append(line)
        else:
            fixed_lines.append(line)
    
    # Join the fixed lines
    fixed_code = '\n'.join(fixed_lines)
    
    # Also fix common problematic patterns
    if "df.col" in fixed_code:
        fixed_code = fixed_code.replace("df.col", "df['column_name']")
        logger.info("Fixed df.col access pattern")
    
    # Return the fixed code
    return fixed_code

def generate_custom_template(description: str, df: pd.DataFrame, template_name: str) -> Dict[str, Any]:
    """
    Generate a custom analysis template based on user description using AI.
    
    Args:
        description: User-provided description of the desired analysis
        df: DataFrame containing the data to analyze
        template_name: Name for the new template
        
    Returns:
        Dict containing the generated template code and metadata
    """
    if not OPENROUTER_API_KEY:
        logger.error("OpenRouter API key not found in environment variables")
        raise ValueError("API key not found. Please set the OPENROUTER_API_KEY environment variable.")
    
    # Prepare dataset information for the AI
    column_info = []
    for col in df.columns:
        dtype = str(df[col].dtype)
        # Convert sample values to Python native types for JSON serialization
        try:
            sample_values = df[col].dropna().sample(min(5, len(df))).tolist()
            # Convert numpy types to Python native types
            sample_values = [int(x) if isinstance(x, np.integer) else 
                            float(x) if isinstance(x, np.floating) else 
                            str(x) if isinstance(x, (np.datetime64, pd.Timestamp)) else x 
                            for x in sample_values]
        except:
            # If sampling fails, just use empty list
            sample_values = []
            
        unique_count = df[col].nunique()
        missing_count = df[col].isna().sum()
        
        column_info.append({
            "name": col,
            "dtype": dtype,
            "unique_values": int(unique_count) if isinstance(unique_count, np.integer) else unique_count,
            "missing_values": int(missing_count) if isinstance(missing_count, np.integer) else missing_count,
            "samples": sample_values
        })
    
    # Get sample code from existing templates for reference
    from templates.analysis_templates import apply_template
    sample_template_code = inspect.getsource(apply_template)
    
    # Prepare the prompt for the AI
    system_message = f"""You are an expert data scientist specializing in creating analysis templates for field data. 
Your task is to create a custom analysis template based on the user's description.

The template should follow this structure:
1. Look for relevant columns in the dataset
2. Process and analyze the data according to the request
3. Create appropriate output for visualization
4. Return a tuple of (result_dataframe, visualization_type, description)

The template will be added to an existing template system. Here's how templates are currently implemented:

```python
{sample_template_code[:500]}...
```

Here's information about the dataset:
{json.dumps(column_info, indent=2)}

When creating the template, follow these guidelines:
- Make the template robust to handle missing or misnamed columns
- Include clear error handling
- Use the find_column helper function to flexibly locate relevant columns
- Return an appropriate visualization type (bar, line, pie, scatter, box, heatmap)
- Format the result data for easy visualization
- IMPORTANT: Do not use 'col' as a variable name except within the scope of loops. Always give more descriptive names such as 'age_col', 'gender_col', etc.
- Always access DataFrame columns using df['column_name'] syntax, not df.column_name
- If you use loops like 'for col in df.columns:', ensure the 'col' variable is only used within the loop's scope
"""

    user_message = f"""Create a custom analysis template called "{template_name}" that does the following:

{description}

Please output ONLY valid Python code for the template function without any other explanations.
The code should be in this format:

elif template_name == "{template_name}":
    description = "Brief description of what this template does"
    
    # Look for relevant columns
    # ... column finding code ...
    
    # Perform the analysis
    # ... analysis code ...
    
    # Create result dataframe
    # ... result formatting code ...
    
    viz_type = "appropriate_viz_type"
    return result, viz_type, description
"""

    # Make the API request to OpenRouter
    try:
        logger.info("Making Template Generator API call to OpenRouter...")
        
        response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                "Content-Type": "application/json"
            },
            json={
                "model": "anthropic/claude-3-opus-20240229",
                "messages": [
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": user_message}
                ]
            }
        )
        
        response_data = response.json()
        logger.info("Template Generator API response received")
        
        if "choices" not in response_data or not response_data["choices"]:
            error_msg = f"Invalid API response: {json.dumps(response_data)}"
            logger.error(error_msg)
            raise ValueError(error_msg)
        
        # Extract the generated code
        generated_code = response_data["choices"][0]["message"]["content"]
        
        # Clean up the code - remove any markdown formatting if present
        if "```python" in generated_code:
            generated_code = generated_code.split("```python")[1].split("```")[0].strip()
        elif "```" in generated_code:
            generated_code = generated_code.split("```")[1].split("```")[0].strip()
        
        # Ensure the code starts with 'elif template_name'
        if not generated_code.strip().startswith("elif template_name"):
            generated_code = f'elif template_name == "{template_name}":\n' + generated_code
        
        # Apply fixes to the generated code
        fixed_code = fix_generated_code(generated_code)
        
        # Extract the description from the generated code
        description_line = [line for line in fixed_code.split('\n') if 'description =' in line]
        description_text = description_line[0].split('=')[1].strip().strip('"\'') if description_line else template_name
        
        # Extract the visualization type
        viz_type_line = [line for line in fixed_code.split('\n') if 'viz_type =' in line]
        viz_type = viz_type_line[0].split('=')[1].strip().strip('"\'') if viz_type_line else "bar"
        
        # Make sure to use string for timestamp to avoid JSON serialization issues
        current_time = pd.Timestamp.now()
        timestamp_str = current_time.isoformat()
        
        return {
            "name": template_name,
            "code": fixed_code,
            "description": description_text,
            "viz_type": viz_type,
            "original_code": generated_code,  # Save the original for reference
            "timestamp": timestamp_str
        }
        
    except Exception as e:
        logger.error(f"Error generating template: {str(e)}")
        raise

def save_custom_template(template: Dict[str, Any]) -> bool:
    """
    Save a custom template to the user's local storage.
    
    Args:
        template: Template dictionary containing code and metadata
        
    Returns:
        bool: Whether the template was successfully saved
    """
    try:
        # Initialize custom templates in session state if not exists
        if 'custom_templates' not in st.session_state:
            st.session_state.custom_templates = {}
        
        # Add/update the template in session state
        st.session_state.custom_templates[template["name"]] = template
        
        # Create templates directory if it doesn't exist
        os.makedirs("custom_templates", exist_ok=True)
        
        # Save to disk
        template_path = os.path.join("custom_templates", f"{template['name'].replace(' ', '_')}.json")
        with open(template_path, 'w') as f:
            json.dump(template, f, indent=2)
        
        return True
    except Exception as e:
        logger.error(f"Error saving template: {str(e)}")
        return False

def load_custom_templates() -> Dict[str, Dict[str, Any]]:
    """
    Load all custom templates from disk.
    
    Returns:
        Dict of template name to template data
    """
    templates = {}
    
    try:
        # Check if directory exists
        if not os.path.exists("custom_templates"):
            return templates
        
        # Load each template file
        for filename in os.listdir("custom_templates"):
            if filename.endswith(".json"):
                try:
                    with open(os.path.join("custom_templates", filename), 'r') as f:
                        template = json.load(f)
                        if "name" in template and "code" in template:
                            templates[template["name"]] = template
                except Exception as e:
                    logger.error(f"Error loading template {filename}: {str(e)}")
        
        return templates
    except Exception as e:
        logger.error(f"Error loading templates: {str(e)}")
        return templates

def get_custom_templates_for_ui() -> Dict[str, str]:
    """
    Get custom templates in a format suitable for the UI.
    
    Returns:
        Dict mapping template names to descriptions
    """
    # Load templates if not in session state
    if 'custom_templates' not in st.session_state:
        st.session_state.custom_templates = load_custom_templates()
    
    # Format for UI
    return {
        template["name"]: template.get("description", template["name"]) 
        for template in st.session_state.custom_templates.values()
    }

def execute_custom_template(template_name: str, df: pd.DataFrame) -> Tuple[pd.DataFrame, str, str]:
    """
    Execute a custom template on the given DataFrame.
    
    Args:
        template_name: Name of the template to execute
        df: DataFrame to analyze
        
    Returns:
        Tuple of (result_df, viz_type, description)
    """
    if 'custom_templates' not in st.session_state or template_name not in st.session_state.custom_templates:
        raise ValueError(f"Template '{template_name}' not found")
    
    template = st.session_state.custom_templates[template_name]
    code = template["code"]
    
    # Import necessary functions
    from templates.analysis_templates import find_column
    
    # Create the execution environment with more complete context
    exec_globals = {
        'pd': pd,
        'np': np,
        'df': df.copy(),  # Use a copy to avoid modifying the original
        'find_column': find_column,
        'columns_lower': [col.lower() for col in df.columns],
        'columns_dict': {col.lower(): col for col in df.columns},
        'numeric_cols': df.select_dtypes(include=np.number).columns.tolist(),
        'categorical_cols': df.select_dtypes(include=['object', 'category']).columns.tolist(),
        'template_name': template_name,
        'result': None,
        'viz_type': None,
        'description': None,
        'logger': logger,
        # Add all column names directly to the globals
        **{col: col for col in df.columns}
    }
    
    # Create a full function to execute with better error handling
    full_code = """
def apply_custom_template(template_name, df):
    try:
        # Preparing variables
        numeric_cols = df.select_dtypes(include=np.number).columns.tolist()
        categorical_cols = df.select_dtypes(include=['object', 'category']).columns.tolist()
        columns_lower = [col.lower() for col in df.columns]
        columns_dict = {col.lower(): col for col in df.columns}
        
        # Make all column names available as variables
        for col_name in df.columns:
            locals()[col_name] = col_name
        
        # Execute the template code
        if False:  # Placeholder to make if-elif structure work
            pass
        {0}
        else:
            raise ValueError(f"Template '{{template_name}}' not found or invalid")
        
        # Ensure result is a DataFrame
        if result is not None and not isinstance(result, pd.DataFrame):
            raise TypeError(f"Template result must be a DataFrame, got {{type(result).__name__}}")
            
        return result, viz_type, description
    except NameError as e:
        # Specific handling for common column reference errors
        error_msg = str(e)
        if "name 'col' is not defined" in error_msg:
            raise ValueError("Column reference error: The template is trying to use 'col' as a variable. "
                            "This might be a code generation error where it's assuming 'col' is defined. "
                            "The template should use specific column names from the dataframe.")
        else:
            # Check if it's likely a missing column name
            var_name = error_msg.split("'")[1] if "'" in error_msg else "unknown"
            if var_name in df.columns:
                raise ValueError(f"Column access error: The template couldn't access column '{{var_name}}'. "
                                f"Try using df['{var_name}'] instead of directly referencing the column name.")
            else:
                raise ValueError(f"Name error in template: {{error_msg}}")
    except Exception as e:
        raise ValueError(f"Error in template execution: {{str(e)}}")
    
# Execute
result, viz_type, description = apply_custom_template(template_name, df)
""".format(code)
    
    try:
        # Execute the code
        exec(full_code, exec_globals)
        
        # Get the results
        result = exec_globals.get('result')
        viz_type = exec_globals.get('viz_type', 'bar')
        description = exec_globals.get('description', template_name)
        
        if result is None:
            raise ValueError("Template execution failed to produce a result")
        
        # Clear any previous errors for this template
        if "Error" in st.session_state and template_name in st.session_state["Error"]:
            del st.session_state["Error"][template_name]
        
        return result, viz_type, description
        
    except Exception as e:
        error_msg = str(e)
        logger.error(f"Error executing template '{template_name}': {error_msg}")
        
        # Store the error in session state for UI handling
        if "Error" not in st.session_state:
            st.session_state["Error"] = {}
        st.session_state["Error"][template_name] = error_msg
        
        # Check the template code for 'col' references
        if 'col' in code and "name 'col' is not defined" in error_msg:
            # Suggest a fix based on the code pattern
            lines = code.split('\n')
            potential_loop_lines = [i for i, line in enumerate(lines) if 'for' in line and 'col' in line]
            
            if potential_loop_lines:
                line_num = potential_loop_lines[0] + 1  # 1-based line number
                raise ValueError(f"The template has a 'col' variable in a loop (around line {line_num}) "
                               f"but tries to use it outside the loop. This is likely a code generation issue.")
        
        raise ValueError(f"Error executing template: {error_msg}") 